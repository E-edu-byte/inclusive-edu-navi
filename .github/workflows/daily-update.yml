# 毎日のニュース収集 & AI記事生成ワークフロー
name: Daily Update

on:
  # 【朝刊・夕刊スタイル】1日2回
  # Free Tier 20RPD対応: 朝刊5件 + 夕刊6件(AIピック含む) = 11件/日
  # GitHub Actionsの遅延（1-2時間）を考慮して早めに設定
  schedule:
    - cron: "0 21 * * *"   # JST 6:00 (UTC 21:00) - 朝刊（実際は7-8時頃実行）
    - cron: "15 8 * * *"   # JST 17:15 (UTC 8:15) - 夕刊（実際は18-19時頃実行）
  # 手動実行も可能
  workflow_dispatch:
    inputs:
      summary_only:
        description: '要約専用モード（新規収集をスキップ）'
        required: false
        default: 'false'
        type: boolean
  # mainブランチへのpush時は実行しない（スケジュールと手動のみ）
  # 以前: pushでも実行していたが、記事データが上書きされる問題があったため無効化
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'scripts/**'
  #     - '.github/workflows/daily-update.yml'

# 二重起動防止（429エラー対策）
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

env:
  # GitHub Secrets から GEMINI_API_KEY を読み込む
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  TZ: Asia/Tokyo

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      # 1. リポジトリをチェックアウト
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Python環境のセットアップ
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: scripts/requirements.txt

      # 3. ライブラリのインストール
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements.txt

      # 3.5. クォータチェック（予約制：ルーティン枠を確保）
      - name: Check API quota with reservation
        id: quota-check
        run: |
          python << 'EOF'
          import json
          import os
          import sys
          from datetime import datetime, timedelta

          STATUS_FILE = "public/data/status.json"
          DAILY_LIMIT = 20

          # ルーティン枠の定義
          MORNING_QUOTA = 5   # 朝刊（7:00 JST）
          EVENING_QUOTA = 6   # 夕刊（18:00 JST）+ AIピック

          # 実行タイプを判定
          schedule = os.environ.get('SCHEDULE', '')
          is_manual = os.environ.get('IS_MANUAL', 'false') == 'true'
          summary_only = os.environ.get('SUMMARY_ONLY', 'false') == 'true'

          if schedule == '0 21 * * *':  # UTC 21:00 = JST 6:00
              run_type = 'morning'
          elif schedule == '15 8 * * *':  # UTC 8:15 = JST 17:15
              run_type = 'evening'
          else:
              run_type = 'manual'

          print(f"実行タイプ: {run_type}")

          def get_quota_period_start():
              """17:00 JSTでリセット"""
              now = datetime.now()
              today_reset = now.replace(hour=17, minute=0, second=0, microsecond=0)
              if now >= today_reset:
                  return today_reset
              else:
                  return today_reset - timedelta(days=1)

          def get_pending_routine_reserve(run_type):
              """今後のルーティン実行のために予約すべき枠を計算"""
              if run_type == 'morning':
                  # 朝刊実行時：この期間のルーティンは終了
                  return 0
              elif run_type == 'evening':
                  # 夕刊実行時：朝刊分を予約
                  return MORNING_QUOTA
              else:  # manual
                  # 手動実行：全ルーティン分を予約
                  return EVENING_QUOTA + MORNING_QUOTA

          # status.json読み込み
          used_in_period = 0
          if os.path.exists(STATUS_FILE):
              with open(STATUS_FILE, 'r', encoding='utf-8') as f:
                  status = json.load(f)
              period_start = get_quota_period_start()
              for entry in status.get("history", []):
                  try:
                      entry_time = datetime.fromisoformat(entry.get("timestamp", ""))
                      if entry_time >= period_start:
                          used_in_period += entry.get("apiCalls", 0)
                  except:
                      continue

          remaining = DAILY_LIMIT - used_in_period
          reserve = get_pending_routine_reserve(run_type)
          available = remaining - reserve

          print(f"=" * 50)
          print(f"使用済み: {used_in_period}/{DAILY_LIMIT}")
          print(f"残り: {remaining}")
          print(f"ルーティン予約: {reserve}")
          print(f"利用可能: {available}")
          print(f"=" * 50)

          # 出力変数を設定
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              if run_type in ['morning', 'evening']:
                  # ルーティン実行：必要枠があるかチェック
                  needed = MORNING_QUOTA if run_type == 'morning' else EVENING_QUOTA
                  if remaining >= needed:
                      f.write("quota_ok=true\n")
                      f.write(f"available={needed}\n")
                      print(f"[OK] ルーティン実行: {needed}件分の枠あり")
                  else:
                      f.write("quota_ok=false\n")
                      f.write("available=0\n")
                      print(f"::error::[NG] ルーティン枠不足: 残り{remaining} < 必要{needed}")
              else:
                  # 非ルーティン実行：予約枠を除いた分のみ利用可能
                  if available > 0:
                      f.write("quota_ok=true\n")
                      f.write(f"available={available}\n")
                      print(f"[OK] 非ルーティン実行: {available}件まで利用可能")
                  else:
                      f.write("quota_ok=false\n")
                      f.write("available=0\n")
                      print(f"::warning::[スキップ] ルーティン予約のため利用可能枠なし")
          EOF
        env:
          SCHEDULE: ${{ github.event.schedule }}
          IS_MANUAL: ${{ github.event_name == 'workflow_dispatch' }}
          SUMMARY_ONLY: ${{ github.event.inputs.summary_only }}

      # 4. ニュース収集（fetch-news.py）- 完全直列処理、15秒間隔
      # 17:10 JST（UTC 8:10）またはsummary_only=trueの場合は要約専用モード
      # --max-calls で利用可能枠を制限
      - name: Fetch news articles
        if: steps.quota-check.outputs.quota_ok == 'true'
        run: |
          AVAILABLE="${{ steps.quota-check.outputs.available }}"
          echo "利用可能API枠: ${AVAILABLE}件"

          if [[ "${{ github.event.inputs.summary_only }}" == "true" ]]; then
            echo "=== 要約専用モード ==="
            python scripts/fetch-news.py --summary-only --max-calls "${AVAILABLE}"
          else
            echo "=== 通常モード ==="
            python scripts/fetch-news.py --max-calls "${AVAILABLE}"
          fi

      # 4.5. 手動記事の期限切れチェック
      - name: Cleanup expired manual articles
        run: python scripts/manual-post.py --cleanup

      # 4.6. ゴミ箱の24時間経過記事を永久削除
      - name: Cleanup expired trash
        run: |
          python << 'EOF'
          import json
          import os
          from datetime import datetime, timedelta

          TRASHED_FILE = "public/data/trashed-articles.json"
          EXCLUDED_FILE = "public/data/excluded-urls.json"

          # ゴミ箱ファイル読み込み
          if not os.path.exists(TRASHED_FILE):
              print("ゴミ箱ファイルが存在しません")
              exit(0)

          with open(TRASHED_FILE, 'r', encoding='utf-8') as f:
              trash_data = json.load(f)

          # 除外URLファイル読み込み
          if os.path.exists(EXCLUDED_FILE):
              with open(EXCLUDED_FILE, 'r', encoding='utf-8') as f:
                  excluded_data = json.load(f)
          else:
              excluded_data = {"excludedUrls": []}

          now = datetime.now()
          expired_urls = []
          remaining_articles = []

          for article in trash_data.get('articles', []):
              trashed_at = datetime.fromisoformat(article['trashedAt'].replace('Z', ''))
              if now - trashed_at > timedelta(hours=24):
                  # 24時間経過 → 永久削除へ
                  expired_urls.append(article['url'])
                  print(f"永久削除: {article['url']}")
              else:
                  remaining_articles.append(article)

          if expired_urls:
              # 除外URLに追加
              for url in expired_urls:
                  if url not in excluded_data['excludedUrls']:
                      excluded_data['excludedUrls'].append(url)

              # ファイル更新
              trash_data['articles'] = remaining_articles
              trash_data['lastUpdated'] = now.isoformat()

              with open(TRASHED_FILE, 'w', encoding='utf-8') as f:
                  json.dump(trash_data, f, ensure_ascii=False, indent=2)

              with open(EXCLUDED_FILE, 'w', encoding='utf-8') as f:
                  json.dump(excluded_data, f, ensure_ascii=False, indent=2)

              print(f"✓ {len(expired_urls)}件を永久削除しました")
          else:
              print("期限切れの記事はありません")
          EOF

      # 5. AI記事生成（generate-articles.py）- 夕刊時のみ実行
      # JST 17:15 (UTC 8:15) - 夕刊
      # クォータがない場合もスキップ
      - name: Generate AI picks (evening edition only)
        if: |
          steps.quota-check.outputs.quota_ok == 'true' &&
          ((github.event_name == 'workflow_dispatch' && github.event.inputs.summary_only != 'true') ||
          github.event_name == 'push' ||
          (github.event_name == 'schedule' && github.event.schedule == '15 8 * * *'))
        run: python scripts/generate-articles.py
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

      # 5.5. サイトマップ生成
      - name: Generate sitemap
        run: python scripts/generate-sitemap.py

      # 5.6. Node.js環境のセットアップ（RSS生成用）
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      # 5.7. npm依存関係のインストール
      - name: Install npm dependencies
        run: npm ci

      # 5.8. RSSフィード生成
      - name: Generate RSS feed
        run: npm run generate-rss

      # 5.9. Google Analytics データ取得
      - name: Fetch Google Analytics data
        run: |
          if [ -n "$GA_SERVICE_ACCOUNT_KEY" ]; then
            echo "$GA_SERVICE_ACCOUNT_KEY" > /tmp/ga-key.json
            export GOOGLE_APPLICATION_CREDENTIALS=/tmp/ga-key.json
            python scripts/fetch-analytics.py
            rm -f /tmp/ga-key.json
          else
            echo "GA_SERVICE_ACCOUNT_KEY が設定されていません。スキップします。"
          fi
        env:
          GA4_PROPERTY_ID: "524851962"
          GA_SERVICE_ACCOUNT_KEY: ${{ secrets.GA_SERVICE_ACCOUNT_KEY }}

      # 6. 変更があるかチェック
      - name: Check for changes
        id: git-check
        run: |
          git add -A
          if git diff --staged --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      # 7. 変更をコミット＆プッシュ
      - name: Commit and push changes
        if: steps.git-check.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add public/data/articles.json public/data/ai-picks.json public/data/status.json public/sitemap.xml public/feed.xml public/data/manual-articles.json public/data/trashed-articles.json public/data/excluded-urls.json public/data/analytics.json
          git commit -m "chore: daily update - news & AI picks $(date +'%Y-%m-%d %H:%M' -d '+9 hours')"
          # リモートに新しいコミットがある場合はrebaseしてからプッシュ
          git pull --rebase origin main || true
          git push origin main

      # 8. デプロイをトリガー（オプション）
      - name: Trigger deploy
        if: steps.git-check.outputs.changed == 'true'
        uses: peter-evans/repository-dispatch@v3
        with:
          event-type: news-updated
